# $Id: CJSGrammar.rdc 110 2011-04-18 17:46:26Z jo $
# The ParseRecDescent grammar used for CJS sheets.
# This is used to generate CJSGrammar.pm and 
# is distributed as documentation.
#

       { my $selector; }

xpath:  /\"[^\"]+\"/ 
        {$return = substr($item[1], 1, -1);}
xpath:  /\S+/
atname: /\w[\w\d.:-]*/

action: /content|replace|omit-tag|condition|comment/
attribute: /attribute/
repeat: /repeat/
selector: /css|xpath/

# A condition is an xpath before a sublist
condition: xpath ..."{"
       {$item[1];}
# Empty injection (comment)
injection: .../\s*;/ {0;}
injection: xpath action <commit> xpath 
       {Cindy::Injection->new(@item[1,2,4], $selector);} 
injection: xpath attribute <commit> xpath atname  
       {Cindy::Injection->new(@item[1,2,4], $selector, 
                              atname => $item{atname});} 
injection: xpath repeat <commit> xpath condition(?) sublist  
       {Cindy::Injection->new(@item[1,2,4], $selector, 
                              sublist => $item{sublist}, 
                              xfilter => $item{'condition(?)'}->[0]);}
# No matches (uncommit to try the resync rule below) 
injection: <error> 
# resume parsing after the next separator and output the error
injection: /[^;]+;[^\n]*\n?/ warn

# The rest of the line after a ; is ignored
# Note that // is not a usable comment delimiter with XPath expressions
comment: /;/ <commit> <skip: qr/[^\n]*/> /\n?/
separator: comment(s)
separator: ..."}"
separator: .../\Z/
separator: <error:Expected ";" but found  "}.($text=~/(.*)\n/,$1).qq{" instead.>
separator: /[^;]+;[^\n]*\n?/ warn

# Switch between selectors
usage: comment(s?) "use" selector separator 
       {$selector = $item{selector};}
# No use statement defaults to xpath
usage: comment(s?) 
       {$selector = 'xpath';}

# A single "statement"
full_injection: injection separator {$item[1];}

# Sublists
sub_injection: ..."}" <commit><reject>
sub_injection: full_injection
sub_injection_list: sub_injection(s) {[grep($_, @{$item[1]})];} 
sublist: "{" <commit> sub_injection_list "}" {$item[3];}

# Main injection list
injection_list: full_injection(s) {[grep($_, @{$item[1]})];} 
complete_injection_list: usage injection_list /\Z/ {$item{injection_list};}
complete_injection_list: <error> | warn

# output error action
warn: {Cindy::Sheet::warn_on_errors($thisparser->{errors});}


